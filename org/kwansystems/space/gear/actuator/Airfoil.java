package org.kwansystems.space.gear.actuator;

import static java.lang.Math.*;

import java.io.*;

import org.kwansystems.space.gear.*;
import org.kwansystems.space.gear.mass.*;
import org.kwansystems.space.planet.atmosphere.*;
import org.kwansystems.space.universe.*;
import org.kwansystems.tools.chart.*;
import org.kwansystems.tools.rotation.*;
import org.kwansystems.tools.table.*;
import org.kwansystems.tools.vector.*;

/**
 * Actuator which creates aerodynamic force and torque.
 * <p>
 * The geometry of an airfoil is as follows:<br>
 *It is attached to the body at CoF by an axle. The axle is in the direction
 *of the Perp vector, which is normal to both the reference normal and the
 *reference chord line. The actual normal and chord are calculated by rotating
 *the reference normal and chord about the perp vector
 *
 *References: http://www.aerospaceweb.org/question/aerodynamics/q0231.shtml
 */
public abstract class Airfoil extends Actuator {
  public static final int CL=0;
  public static final int CD=1;
  public static final int CM=2;
  private MathVector ReferenceNormal;
  private MathVector ReferenceChordLine;
  private MathVector Normal;
  private MathVector ChordLine;
  private MathVector Perp;
  //Angle airfoil is rotated around Perp from reference normal and chord, radians
  private double AirfoilAngle;
  private MathMatrix VesselToWing;
  private double Chord; 
  protected double SurfaceArea; 
  protected double Aspect;
  private double Wingspan;
  public double SurfaceAreaFactor;
  public enum LiftModel {
	  Planar,Axial  
  }
  private LiftModel Model;
  static double TransonicDragMax=0.620;
  static double TransonicDragTableMax=0.620;
  static Table TransonicDragFactor=new QuadraticTable(0,5,new double[][] 
  {{0.130,0.128,0.125,0.123,0.121,0.123,0.125,0.127,0.129,0.131,0.135,  //Mach 0.00-0.50
          0.143,0.150,0.162,0.178,0.210,0.255,0.295,0.335,0.385,0.435,  //Mach 0.55-1.00
          0.485,0.535,0.570,0.600,0.610,0.617,0.620,0.620,0.617,0.616,  //Mach 1.05-1.50
          0.610,0.606,0.600,0.592,0.585,0.577,0.572,0.562,0.552,0.545,  //Mach 1.55-2.00
          0.533,0.525,0.516,0.507,0.499,0.491,0.483,0.476,0.470,0.463,  //Mach 2.05-2.50
          0.455,0.451,0.447,0.441,0.437,0.431,0.429,0.422,0.418,0.415,  //Mach 2.55-3.00
          0.411,0.408,0.404,0.401,0.399,0.395,0.391,0.389,0.387,0.382,  //Mach 3.05-3.50
          0.381,0.380,0.378,0.375,0.371,0.370,0.369,0.367,0.364,0.362,  //Mach 3.55-4.00
          0.360,0.359,0.358,0.357,0.356,0.354,0.353,0.352,0.351,0.350,  //Mach 4.05-4.50
          0.349,0.348,0.347,0.347,0.346,0.345,0.344,0.343,0.342,0.342}} //Mach 4.55-5.00
	 );

  /**
   * Creates a new airfoil.
   * @param LName Name of this airfoil
   * @param LCoF Center of force, station frame, m
   * @param LPerp Unit vector perpendicular to wing chord, in airfoil plane
   * @param LChordLine Unit vector parallel to wing chord
   * @param LChord Length of wing chord, m
   * @param LWingspan Span of airfoil, m
   */
  public Airfoil(String LName, MathVector LCoF, MathVector LPerp, MathVector LChordLine, double LChord, double LWingspan, LiftModel LModel) {
    super(LName,LCoF);
    ReferenceChordLine=LChordLine.normal();
    Perp=LPerp.normal();
    ReferenceNormal=MathVector.cross(ReferenceChordLine,Perp).normal();
    setAirfoilAngle(0); 
    Chord=LChord;
    Wingspan=LWingspan;
    SurfaceArea=Chord*Wingspan; 
    Aspect=Wingspan/Chord;
    Model=LModel;
    SurfaceAreaFactor=1;
  }
  public Airfoil(String LName, MathVector LCoF, MathVector LPerp, MathVector LChordLine, double LChord, double LWingspan) {
	  this(LName, LCoF, LPerp, LChordLine, LChord, LWingspan, LiftModel.Planar);
  }
  /**
   * Sets angle of airfoil relative to its reference position
   * @param LAirfoilAngle Angle of right handed rotation about Perp, rad
   */
  public void setAirfoilAngle(double LAirfoilAngle) {
    AirfoilAngle=LAirfoilAngle;
    double c=cos(AirfoilAngle);
    double s=sin(AirfoilAngle);
    Normal=MathVector.add(ReferenceNormal.mul(c),ReferenceChordLine.mul(-s));
    ChordLine=MathVector.add(ReferenceNormal.mul(s),ReferenceChordLine.mul(c));
    VesselToWing=MathMatrix.rowMatrix(ChordLine,Perp,Normal);
  }
  public double oapiGetWaveDrag(double M) {
	  M=M>5?5:M;
	  return TransonicDragFactor.Interp(M,0)*TransonicDragMax/TransonicDragTableMax;
  }
  /**
   * Calculate lift, drag, and moment coefficients
   * @param aoa Angle of attack, radians
   * @param M Mach number
   * @param Re Reynolds number
   * @return Array of coefficients in order [lift,drag,moment]
   */
  public abstract double[] C(double aoa, double M, double Re); 
  
  /**
   * Calculates force and torque generated by airfoil
   * @param T Simulation time, s
   * @param RVEw Simulation state in inertial frame, m, s, rad
   * @param Mass Mass of vehicle at this time, kg
   * @param CoM Center of mass in station coordinates, m
   * @param U Universe the vehicle is in
   * @return WingForceTorque object containing force on center of mass, in body 
   * frame, N, and torque about center of mass, in body frame, Nm, as well as 
   * a whole bunch of stuff about the wing-air interaction.
   */
  public ForceTorque getForceTorque(double T, SixDOFState RVEw, double Mass, MathVector CoM, Universe U) {
    WingForceTorque WFT=new WingForceTorque(T,RVEw,U,CoF,CoM);
    if(WFT.rho==0.0) return WFT;
    double RelSpd=WFT.WingWindBody.length();
    if(RelSpd==0.0) {
      return WFT;
    }
    WFT.Aspect=Aspect; 
    WFT.FoilChord=Chord;
    WFT.FoilSpan=Wingspan;
    WFT.FoilArea=SurfaceArea;
    if(WFT.mu>0) {
      WFT.Re=WFT.rho*RelSpd*Chord/WFT.mu;
    } else {
      WFT.Re=0;
    }

    WFT.WingWind=VesselToWing.transform(WFT.WingWindBody);
    WFT.WingWindNormal=WFT.WingWind.normal();
    WFT.alpha=Math.atan2(WFT.WingWindNormal.Z(),-WFT.WingWindNormal.X());
    WFT.beta= Math.atan2(WFT.WingWindNormal.Y(),-WFT.WingWindNormal.X());
    WFT.AoA=  Math.acos(-WFT.WingWindNormal.X());
    double[] c=new double[0];
    switch(Model) {
      case Planar:
        c=C(WFT.alpha,WFT.Mach,WFT.Re);
    	  break;
      case Axial:
        c=C(WFT.AoA  ,WFT.Mach,WFT.Re);
      	break;
    }
    
    WFT.cL=c[CL];
    WFT.cD=c[CD];
    WFT.cM=c[CM];
    WFT.q=WFT.rho*RelSpd*RelSpd/2;
    
    //Convert things to normal and axial, so we can direct the force properly
    double ca=cos(WFT.alpha);
    double sa=sin(WFT.alpha);
    WFT.cN= WFT.cL*ca+WFT.cD*sa;
    WFT.cA=-WFT.cL*sa+WFT.cD*ca;
    double NormalForce=WFT.cN*WFT.q*SurfaceArea*SurfaceAreaFactor;
    double AxialForce=WFT.cA*WFT.q*SurfaceArea*SurfaceAreaFactor;
    double Moment=WFT.cM*WFT.q*SurfaceArea*Chord*SurfaceAreaFactor;
    
    WFT.AxialForce=ChordLine.mul(-AxialForce);

    switch(Model) {
      case Planar:
   	    WFT.NormalForce=Normal.mul(NormalForce); 
   	    break;
      case Axial:
     		MathVector AxialPerp=MathVector.cross(ChordLine,WFT.WingWindNormal);
     		if(AxialPerp.length() > 0) {
   	  	  AxialPerp=AxialPerp.normal();
     	    MathVector AxialNormal=MathVector.cross(AxialPerp,ChordLine);
          WFT.NormalForce=AxialNormal.mul(NormalForce);
   		  } else {
          WFT.NormalForce=new MathVector(0,0,0);
   		  }
    	  break;
    }
    WFT.Force=MathVector.add(WFT.NormalForce,WFT.AxialForce); 
    WFT.TorqueF=MathVector.cross(WFT.CoFOffset,WFT.Force); //Moment due to off-axis force
    WFT.TorqueL=Perp.mul(Moment);
    WFT.Torque=MathVector.add(WFT.TorqueF,WFT.TorqueL);
    return WFT;
  }
  public static void main(String args[]) throws IOException {
    ChartRecorder C=new ArrayListChartRecorder(1000,20);
    Universe U=new FlatEarth(
      0,
      new FlatAtmosphere(new KwanLowerAtmosphere(),0,10000),
      new MathVector(0,0,0)
    );
    SixDOFVehicle TV=new SixDOFVehicle(U,null,C) {
      /*
      public MathVector Constrain(double T, MathVector X) {
        MathVector SuperConstrain=super.Constrain(T,X);
        MathVector NonRV=SuperConstrain.subVector(6);
        return new MathVector(new MathVector[]{new MathVector(6),NonRV});
      }
      */
      @Override
      public void Discrete(double T, SixDOFState RVEw, MathVector FuelLevels) { }
      public void Steer(double T, SixDOFState RVEw, boolean IsMajor, MathVector SteerVector) { } 
    };
    TV.AddMass(InertSixDOFMass.MakeSolidCylinder("Fuselage", 1, 0.05, -1, 1));
    final Airfoil PA1=new FlatPlateAirfoil("PlanarAirfoil1",      new MathVector(-1,0.25,0), new MathVector(0,1,0), new MathVector(1,0,0), 0.2, 0.5, 0.25);
    final Airfoil PA2=new FlatPlateAirfoil("PlanarAirfoil2",      new MathVector(-1,-0.25,0), new MathVector(0,1,0), new MathVector(1,0,0), 0.2, 0.5, 0.25);
    PA1.setAirfoilAngle(Math.toRadians(0));
    TV.AddActuator(PA1);
    PA2.setAirfoilAngle(Math.toRadians(0));
    TV.AddActuator(PA2);
    System.out.println(TV.EquivalentMass(0,null));
    TestStand T=new TestStand(TV,new MathVector(0,0,0),C) {
      public void RecordTestData(double T, MathVector X) {
        SixDOFState RVEw=new SixDOFState(X);
        CR.Record(T,"State","m,s",RVEw);
        SixDOFMass M=TestVehicle.EquivalentMass(T,RVEw); 
        CR.Record(T,"CoM","m",M.getCoM(T,RVEw));
      }
    };
    T.DoTest(new SixDOFState(new MathVector(),new MathVector(),Quaternion.U,new MathVector(1,0,0)),0.0,100,10,new double[] {});
    C.PrintTable(new HTMLPrinter("WindTunnelTelementry.html"));
    ChartRecorder C2=new ArrayListChartRecorder(1000,20);
    Object[] PAFT=C.getColumn("PlanarAirfoil1ForceTorque");
    double[] T2=C.getT();
    for(int i=0;i<T2.length;i++) {
      if(PAFT[i]!=null) {
        C2.Record(T2[i], "WingAlpha", "deg", Math.toDegrees(((WingForceTorque)PAFT[i]).alpha));
        C2.Record(T2[i], "BodyAlpha", "deg", Math.toDegrees(((WingForceTorque)PAFT[i]).BodyAlpha));
      }
    }
    C2.EndOfData();
    C2.PrintSubTable(new String[] {"WingAlpha","BodyAlpha"} , new DisplayPrinter());
    
    C.PrintSubTable(new String[] {"State","CoM"},new POVColumnPrinter("WindTunnelState.inc","State"));
    
  }
}
