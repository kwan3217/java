package org.kwansystems.space.gear;
 
import org.kwansystems.space.gear.actuator.*;
import org.kwansystems.space.gear.guidance.*;
import org.kwansystems.space.gear.mass.*;
import org.kwansystems.space.universe.*;
import org.kwansystems.tools.chart.*;
import org.kwansystems.tools.integrator.*;
import org.kwansystems.tools.rotation.*;
import org.kwansystems.tools.vector.*;

import java.util.*;

import static java.lang.Math.*; 

//Take a SixDOF and tack on any other integration variables you want, like fuel levels for instance
public abstract class SixDOFVehicle extends SixDOF implements Constraint { 
  protected List<SixDOFMass> Masses;
  protected List<PropRes> Props;
  protected List<Actuator> Actuators;
  protected List<Thruster> Thrusters;
  public Universe U;
  Guidance G;
  ChartRecorder C;
  public void Record(double T, String Column, String Units, Object value) {
    if(C!=null) C.Record(T,Column,Units,value);
  }
  //Forces generated by the actuators (thrusters, airfoils, contact/collision, etc). These are calculated in body frame
  //to make things easy and relatively constant. Returns total actuator force in N, and torque in N*m, in body frame
  public ForceTorque ActuatorForceTorque(double T, SixDOFState RVEw, boolean IsMajor) {
    ForceTorque TotalForceTorque=new ForceTorque();
    InertSixDOFMass EM=EquivalentMass(T,RVEw);
    for(Actuator A:Actuators) {
      if(A.Active) {
        ForceTorque ThisForceTorque=A.getForceTorque(T,RVEw,EM.mass,EM.CoM,U);
        if(IsMajor) {
          Record(T, A.Name+"ForceTorque", "N,m", ThisForceTorque);
        }
        TotalForceTorque=TotalForceTorque.add(ThisForceTorque);
      }
    }
    if(IsMajor) {
      Record(T,"EquivalentMass","kg,m",EM);
      Record(T,"TotalForceTorque","N,m",TotalForceTorque);
    }
    return TotalForceTorque;
  }
  //Returns strapdown accelerometer reading. This is solely the actuator acceleration.
  //Returns reading in m/s^2, in body frame. Strapdown accelerometer is assumed to be at vehicle
  //center of rotation, so no centrifugal force as a result of vehicle rotation
  public MathVector StrapdownAccelerometer(double T, SixDOFState RVEw) {
    return ActuatorForceTorque(T,RVEw,false).Force.div(EquivalentMass(T,RVEw).mass);
  }
  public MathVector InertialAccelerometer(double T, SixDOFState RVEw) {
    return RVEw.E().invTransform(StrapdownAccelerometer(T,RVEw));
  }
  public ForceTorque getForceTorque(double T, SixDOFState RVEw, boolean IsMajor) {
    ForceTorque result=ActuatorForceTorque(T,RVEw,IsMajor);
    result.Force=RVEw.E().transform(result.Force);
    result.Force=MathVector.add(result.Force,U.EnvironmentAcc(T,RVEw).mul(EquivalentMass(T,RVEw).mass));
    return result;
  }
  public InertSixDOFMass EquivalentMass(double T, SixDOFState RVEw) {
    return InertSixDOFMass.CombineMass(String.format("SixDOFVehicle Mass at time %f",T),Masses, T, RVEw);
  }
  private void SetFuelLevels(MathVector FuelX) {
    for(int i=0;i<FuelX.dimension();i++) {
      Props.get(i).Level=FuelX.get(i);
    }
  }
  public MathVector GetFuelLevels() {
	double[] result=new double[Props.size()];
    for(int i=0;i<result.length;i++) {
      result[i]=Props.get(i).Level;
    }
    return new MathVector(result);
  }
  public Quaternion StraightAhead(double T, MathState RVEw, boolean IsRelWind) {
    MathVector Tail=U.LocalVertical(T,RVEw);
    MathVector Vel=RVEw.V();
    if(IsRelWind) {
      Vel=MathVector.sub(Vel,U.getWind(T,RVEw));
    }
    MathVector Nose=Vel.ProjPerp(Tail).normal();
    MathVector Wing=MathVector.cross(Tail,Nose);
    MathMatrix M=new MathMatrix(new double[][] {Nose.get(),Wing.get(),Tail.get()}).T();
    Quaternion result=new Quaternion(M);
    return result;
  }
  public abstract void Steer(double T, SixDOFState RVEw, boolean IsMajor, MathVector SteerVector);
  public abstract void Discrete(double T, SixDOFState RVEw, MathVector FuelLevels);
  //Calculate the plumbing
  private MathVector fueldxdt(double T, MathVector FuelX, SixDOFState RVEw) {
    double[] PropUsed=new double[Props.size()];
    for(Thruster Th:Thrusters) { //For each thruster
      if(Th!=null && Th.Active) {
        int[] Plumbing=Th.PropTank;
        double[] PropUsedThruster=Th.PropFlowRate(T,RVEw,U);
        for(int PlumbingIdx=0;PlumbingIdx<Plumbing.length;PlumbingIdx++) { //For each used tank
          int ThisTank=Plumbing[PlumbingIdx];
          if(Props.get(ThisTank).Level<=0 ) {
            Th.OutOfFuel(PlumbingIdx);
          }
          PropUsed[Plumbing[PlumbingIdx]]+=PropUsedThruster[PlumbingIdx];
        }
      }
    }
    for(int PropIdx=0;PropIdx<Props.size();PropIdx++) {
      PropUsed[PropIdx]/=-Props.get(PropIdx).FullMass;
    }
    return new MathVector(PropUsed);
  }
  public MathVector dxdt(double T, MathVector X, boolean IsMajor) {
    MathVector SixDOFX=X.subVector(0,13);
    MathVector FuelX=X.subVector(13);
    SixDOFState RVEw=new SixDOFState(SixDOFX);
    SetFuelLevels(FuelX);
    if(G!=null)G.Guide(T,RVEw,FuelX,IsMajor);
    Discrete(T,RVEw,FuelX);
    MathVector SixDOFXdot=super.dxdt(T,SixDOFX, IsMajor);
    MathVector FuelXDot=fueldxdt(T,FuelX,RVEw);
    return new MathVector(new MathVector[]{SixDOFXdot,FuelXDot});
  }
  public MathVector Constrain(double T, MathVector X) {
    double[] FuelX=X.subVector(13).get();
    for(int i=0;i<FuelX.length;i++) {
      if(FuelX[i]<0) {
        FuelX[i]=0;
      }
    }
    return new MathVector(new MathVector[]{super.Constrain(T,X),new MathVector(FuelX)});
  }
  public int FindActuator(String Name) {
    for(int i=0;i<Actuators.size();i++) {
      if(Actuators.get(i).Name.equals(Name))return i;
    }
    throw new IllegalArgumentException("Actuator "+Name+" not found");
  }
  public Actuator AddActuator(Actuator A) {
  	Actuators.add(A);
	  return A;
  }
  public int FindThruster(String Name) {
    for(int i=0;i<Thrusters.size();i++) {
      if(Thrusters.get(i).Name.equals(Name))return i;
    }
    throw new IllegalArgumentException("Thruster "+Name+" not found");
  }
  public Thruster AddThruster(Thruster Th) {
	  AddActuator(Th);
	  Thrusters.add(Th);
	  return Th;
  }
  public int FindMass(String Name) {
    for(int i=0;i<Masses.size();i++) {
      if(Masses.get(i).Name.equals(Name))return i;
    }
    throw new IllegalArgumentException("Mass "+Name+" not found");
  }
  public SixDOFMass AddMass(SixDOFMass M) {
	  Masses.add(M);
	  return M;
  }
  public int FindProp(String Name) {
    for(int i=0;i<Props.size();i++) {
      if(Props.get(i).Name.equals(Name))return i;
    }
    throw new IllegalArgumentException("Prop "+Name+" not found");
  }
  public PropRes AddProp(PropRes P) {
	  AddMass(P);
	  Props.add(P);
	  return P;
  }
  public SixDOFVehicle(Universe LU,Guidance LG,ChartRecorder LC) {
    U=LU;
    G=LG;
    C=LC;
    if (G!=null) G.setVehicle(this);
    Masses=new ArrayList<SixDOFMass>();
    Props=new ArrayList<PropRes>();
    Actuators=new ArrayList<Actuator>();
    Thrusters=new ArrayList<Thruster>();
  }
  public SixDOFVehicle(Universe LU,Guidance LG) {
    this(LU,LG,null);
  }
  public SixDOFVehicle(Universe LU) {
    this(LU,null);
  }
}
